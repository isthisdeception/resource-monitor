#!/usr/bin/env bash
# modules/process.sh  (safer version)
# Provides:
#  - get_top_cpu [N]
#  - get_top_mem [N]
#  - kill_process <PID>   -> prints status and returns 0 on success, 1 on failure

: "${PS:=ps}"
: "${AWK:=awk}"
: "${SORT:=sort}"
: "${HEAD:=head}"

get_top_cpu() {
  local n=${1:-5}
  ${PS} -eo pid,user,%cpu,%mem,comm --no-headers \
    | ${AWK} '{ printf "%6s|%8s|%5s|%5s|%s\n", $1, $2, $3, $4, $5 }' \
    | ${SORT} -t'|' -k3 -nr \
    | ${HEAD} -n "$n"
}

get_top_mem() {
  local n=${1:-5}
  ${PS} -eo pid,user,%cpu,%mem,comm --no-headers \
    | ${AWK} '{ printf "%6s|%8s|%5s|%5s|%s\n", $1, $2, $3, $4, $5 }' \
    | ${SORT} -t'|' -k4 -nr \
    | ${HEAD} -n "$n"
}

# Safe kill_process: Never exits the shell. Returns 0 on success, 1 on failure.
kill_process() {
  local pid="$1"

  # Validate PID format
  if ! [[ "$pid" =~ ^[0-9]+$ ]]; then
    echo "ERROR: invalid pid: $pid" >&2
    return 1
  fi

  # Protect critical/system/monitor processes
  local mypid="$$"         # PID of the running monitor shell
  local myppid="$PPID"     # parent PID of the monitor
  if [[ "$pid" -eq "$mypid" ]]; then
    echo "Refusing to kill the monitor process (PID $pid)."
    return 1
  fi
  if [[ "$pid" -eq "$myppid" ]]; then
    echo "Refusing to kill the parent shell (PID $pid)."
    return 1
  fi
  if [[ "$pid" -eq 1 ]]; then
    echo "Refusing to kill PID 1 (init/system)."
    return 1
  fi

  # Check existence
  if ! kill -0 "$pid" 2>/dev/null; then
    echo "No such process: $pid"
    return 1
  fi

  # Try graceful termination (SIGTERM)
  if ! kill -15 "$pid" 2>/dev/null; then
    echo "Failed to send SIGTERM to $pid"
    return 1
  fi

  # Wait up to ~3 seconds for it to exit (check every 0.1s)
  local i=0
  while kill -0 "$pid" 2>/dev/null && (( i < 30 )); do
    sleep 0.1
    ((i++))
  done

  if kill -0 "$pid" 2>/dev/null; then
    # still alive -> escalate to SIGKILL
    if kill -9 "$pid" 2>/dev/null; then
      # small delay to let kernel cleanup
      sleep 0.1
      if ! kill -0 "$pid" 2>/dev/null; then
        echo "Process $pid force killed"
        return 0
      else
        echo "Failed to kill $pid after SIGKILL"
        return 1
      fi
    else
      echo "Failed to send SIGKILL to $pid"
      return 1
    fi
  else
    echo "Process $pid terminated"
    return 0
  fi
}
